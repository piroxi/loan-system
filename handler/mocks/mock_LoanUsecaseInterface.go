// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"
	entity "loan-service/entity"

	mock "github.com/stretchr/testify/mock"
)

// LoanUsecaseInterface is an autogenerated mock type for the LoanUsecaseInterface type
type LoanUsecaseInterface struct {
	mock.Mock
}

// AddInvestment provides a mock function with given fields: ctx, investmentRequest, investorID
func (_m *LoanUsecaseInterface) AddInvestment(ctx context.Context, investmentRequest entity.RequestAddInvestment, investorID uint) (*entity.Investment, error) {
	ret := _m.Called(ctx, investmentRequest, investorID)

	if len(ret) == 0 {
		panic("no return value specified for AddInvestment")
	}

	var r0 *entity.Investment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, entity.RequestAddInvestment, uint) (*entity.Investment, error)); ok {
		return rf(ctx, investmentRequest, investorID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, entity.RequestAddInvestment, uint) *entity.Investment); ok {
		r0 = rf(ctx, investmentRequest, investorID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Investment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, entity.RequestAddInvestment, uint) error); ok {
		r1 = rf(ctx, investmentRequest, investorID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApproveLoan provides a mock function with given fields: approvalRequest, validatorID
func (_m *LoanUsecaseInterface) ApproveLoan(approvalRequest entity.RequestApproveLoan, validatorID uint) (*entity.LoanApproval, error) {
	ret := _m.Called(approvalRequest, validatorID)

	if len(ret) == 0 {
		panic("no return value specified for ApproveLoan")
	}

	var r0 *entity.LoanApproval
	var r1 error
	if rf, ok := ret.Get(0).(func(entity.RequestApproveLoan, uint) (*entity.LoanApproval, error)); ok {
		return rf(approvalRequest, validatorID)
	}
	if rf, ok := ret.Get(0).(func(entity.RequestApproveLoan, uint) *entity.LoanApproval); ok {
		r0 = rf(approvalRequest, validatorID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.LoanApproval)
		}
	}

	if rf, ok := ret.Get(1).(func(entity.RequestApproveLoan, uint) error); ok {
		r1 = rf(approvalRequest, validatorID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLoan provides a mock function with given fields: loanRequest, borrowerID
func (_m *LoanUsecaseInterface) CreateLoan(loanRequest entity.RequestProposeLoan, borrowerID uint) (*entity.Loan, error) {
	ret := _m.Called(loanRequest, borrowerID)

	if len(ret) == 0 {
		panic("no return value specified for CreateLoan")
	}

	var r0 *entity.Loan
	var r1 error
	if rf, ok := ret.Get(0).(func(entity.RequestProposeLoan, uint) (*entity.Loan, error)); ok {
		return rf(loanRequest, borrowerID)
	}
	if rf, ok := ret.Get(0).(func(entity.RequestProposeLoan, uint) *entity.Loan); ok {
		r0 = rf(loanRequest, borrowerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Loan)
		}
	}

	if rf, ok := ret.Get(1).(func(entity.RequestProposeLoan, uint) error); ok {
		r1 = rf(loanRequest, borrowerID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisburseLoan provides a mock function with given fields: disbursementRequest, disburserID
func (_m *LoanUsecaseInterface) DisburseLoan(disbursementRequest entity.RequestDisburseLoan, disburserID uint) (*entity.LoanDisbursement, error) {
	ret := _m.Called(disbursementRequest, disburserID)

	if len(ret) == 0 {
		panic("no return value specified for DisburseLoan")
	}

	var r0 *entity.LoanDisbursement
	var r1 error
	if rf, ok := ret.Get(0).(func(entity.RequestDisburseLoan, uint) (*entity.LoanDisbursement, error)); ok {
		return rf(disbursementRequest, disburserID)
	}
	if rf, ok := ret.Get(0).(func(entity.RequestDisburseLoan, uint) *entity.LoanDisbursement); ok {
		r0 = rf(disbursementRequest, disburserID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.LoanDisbursement)
		}
	}

	if rf, ok := ret.Get(1).(func(entity.RequestDisburseLoan, uint) error); ok {
		r1 = rf(disbursementRequest, disburserID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLoan provides a mock function with given fields: loanID
func (_m *LoanUsecaseInterface) GetLoan(loanID string) (*entity.Loan, error) {
	ret := _m.Called(loanID)

	if len(ret) == 0 {
		panic("no return value specified for GetLoan")
	}

	var r0 *entity.Loan
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*entity.Loan, error)); ok {
		return rf(loanID)
	}
	if rf, ok := ret.Get(0).(func(string) *entity.Loan); ok {
		r0 = rf(loanID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Loan)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(loanID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectLoan provides a mock function with given fields: rejectionRequest, validatorID
func (_m *LoanUsecaseInterface) RejectLoan(rejectionRequest entity.RequestRejectLoan, validatorID uint) (*entity.LoanApproval, error) {
	ret := _m.Called(rejectionRequest, validatorID)

	if len(ret) == 0 {
		panic("no return value specified for RejectLoan")
	}

	var r0 *entity.LoanApproval
	var r1 error
	if rf, ok := ret.Get(0).(func(entity.RequestRejectLoan, uint) (*entity.LoanApproval, error)); ok {
		return rf(rejectionRequest, validatorID)
	}
	if rf, ok := ret.Get(0).(func(entity.RequestRejectLoan, uint) *entity.LoanApproval); ok {
		r0 = rf(rejectionRequest, validatorID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.LoanApproval)
		}
	}

	if rf, ok := ret.Get(1).(func(entity.RequestRejectLoan, uint) error); ok {
		r1 = rf(rejectionRequest, validatorID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewLoanUsecaseInterface creates a new instance of LoanUsecaseInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLoanUsecaseInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *LoanUsecaseInterface {
	mock := &LoanUsecaseInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
